# Jeeves WebSocket Protocol Documentation

**Version**: 1.0.0  
**Last Updated**: 2025-12-30  
**Document Status**: For Dev Team Reference

---

## 1. Overview

The Jeeves WebSocket protocol enables real-time bidirectional communication between clients and the Jeeves server. All messages are encoded in JSON format, providing a structured, extensible framework for message routing and processing. This protocol replaces the legacy text-based prefix protocol with a modern JSON-based envelope structure.

The protocol is designed to support:
- Real-time audio streaming from clients
- Wake word detection notifications
- Session state management
- Configuration exchange
- Error reporting and recovery

### Key Design Principles

- **Structured Messaging**: Every message follows a consistent envelope structure
- **Type-Based Routing**: Message types enable clear identification and handling
- **Correlation Tracking**: UUID-based message IDs enable request-response correlation
- **Extensibility**: Unknown message types can be safely ignored for forward compatibility

---

## 2. Connection Setup

### 2.1 Establishing a WebSocket Connection

Clients connect to the WebSocket server using the following endpoint pattern:

```
ws://<server_host>:<port>/ws
```

Or for secure connections:

```
wss://<server_host>:<port>/ws
```

### 2.2 Connection Lifecycle

| Phase | Description |
|-------|-------------|
| **Connect** | Client establishes TCP connection and upgrades to WebSocket |
| **Hello** | Server sends `audio_stream_started` with initial configuration |
| **Session** | Normal operation with audio streaming and control messages |
| **Disconnect** | Either party closes the connection; server sends `audio_stream_stopped` |

### 2.3 Connection Sequence

```
Client                              Server
  |                                    |
  |---- WebSocket Handshake --------->|  (HTTP Upgrade)
  |<--- 101 Switching Protocols ------|  (WS Upgrade Confirmed)
  |                                    |
  |<--- audio_stream_started ---------|  (Server sends config)
  |---- audio_data (continuous) ----->|  (Audio stream begins)
```

### 2.4 Recommended Connection Parameters

```json
{
  "websocket": {
    "max_payload": 1048576,
    "ping_interval": 30000,
    "ping_timeout": 10000,
    "auto_reconnect": true
  }
}
```

---

## 3. Message Format

### 3.1 Envelope Structure

All messages share a common envelope structure that ensures consistent handling, debugging, and routing:

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440000",
  "type": "wake_word_detected",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "payload": { },
  "metadata": { },
  "correlation_id": "550e8400-e29b-41d4-a716-446655440001"
}
```

### 3.2 Envelope Field Reference

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `message_id` | UUID | Yes | Unique identifier for every message. Generated by sender. |
| `type` | String | Yes | Message type identifier (enumerated in Section 4). |
| `timestamp` | ISO 8601 | Yes | UTC timestamp of message creation (e.g., `2025-12-30T10:58:25.000Z`). |
| `direction` | Enum | Yes | `server_to_client` or `client_to_server`. |
| `payload` | Object | No | Message-type-specific data content. |
| `metadata` | Object | No | Additional context for debugging (client info, trace IDs, server version). |
| `correlation_id` | UUID | No | References the `message_id` this message responds to. |

### 3.3 Type Naming Conventions

| Pattern | Example | Direction | Description |
|---------|---------|-----------|-------------|
| `{action}_detected` | `wake_word_detected` | S→C | Event notifications |
| `{state}_started` | `audio_stream_started` | S→C | State change notifications |
| `{state}_completed` | `recording_completed` | S→C | State completion notifications |
| `{operation}_result` | `transcription_result` | S→C | Operation results |
| `{operation}_error` | `error_occurred` | S→C | Error notifications |
| `start_{noun}` | `start_recording` | C→S | Action commands |
| `stop_{noun}` | `stop_recording` | C→S | Stop commands |
| `get_{noun}` | `get_status` | C→S | Query requests |
| `send_{noun}` | `send_config` | C→S | Data submissions |

### 3.4 Complete Envelope Example

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440000",
  "type": "wake_word_detected",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "payload": {
    "wake_word": "alexa",
    "confidence": 0.87,
    "audio_timestamp": "2025-12-30T10:58:24.950Z"
  },
  "metadata": {
    "server_version": "1.2.0",
    "session_id": "sess_abc123"
  }
}
```

---

## 4. Message Types

### 4.1 Server→Client Message Types

| Type | Category | Description |
|------|----------|-------------|
| `wake_word_detected` | Event | Wake word detected, entering streaming mode |
| `session_mode_changed` | State | Server mode changed (listening, recording, etc.) |
| `status_update` | Status | General status updates with progress information |
| `config_payload` | Config | Server sends configuration to client |
| `transcription_result` | Result | Transcription of recorded audio |
| `audio_stream_started` | Event | Client audio stream connected |
| `audio_stream_stopped` | Event | Client audio stream disconnected |
| `error_occurred` | Error | Error occurred during processing |
| `heartbeat` | System | Keep-alive ping from server |

### 4.2 Client→Server Message Types

| Type | Category | Description |
|------|----------|-------------|
| `start_recording` | Command | Manually start recording audio |
| `stop_recording` | Command | Manually stop recording audio |
| `send_config` | Config | Client sends configuration to server |
| `request_config` | Query | Client requests server configuration |
| `request_status` | Query | Client requests current server status |
| `reset_session` | Command | Reset the current session state |
| `audio_data` | Data | Raw audio data chunks |
| `ping` | System | Client keep-alive ping |
| `subscribe` | Command | Subscribe to specific event types |
| `unsubscribe` | Command | Unsubscribe from event types |

### 4.3 Server→Client Messages

#### 4.3.1 Wake Word Detected

**Type**: `wake_word_detected`

Signal that wake word was detected, triggering a mode change to recording.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440000",
  "type": "wake_word_detected",
  "timestamp": "2025-12-30T10:58:24.950Z",
  "direction": "server_to_client",
  "payload": {
    "wake_word": "alexa",
    "confidence": 0.87,
    "audio_timestamp": "2025-12-30T10:58:24.945Z",
    "threshold_used": 0.5,
    "model_info": {
      "name": "openwakeword",
      "version": "0.1.0"
    }
  }
}
```

**Payload Schema**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `wake_word` | String | Yes | The detected wake word (e.g., "alexa", "hey_siri"). |
| `confidence` | Number | Yes | Confidence score of the detection (0.0 to 1.0). |
| `audio_timestamp` | ISO 8601 | No | Timestamp when the wake word was detected in the audio stream. |
| `threshold_used` | Number | No | The detection threshold that was applied. |
| `model_info` | Object | No | Information about the wake word model used. |

---

#### 4.3.2 Session Mode Changed

**Type**: `session_mode_changed`

Notify when server changes modes. This is the primary state transition notification.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440001",
  "type": "session_mode_changed",
  "timestamp": "2025-12-30T10:58:24.955Z",
  "direction": "server_to_client",
  "payload": {
    "previous_mode": "listening",
    "current_mode": "recording",
    "reason": "Wake word detected",
    "mode_data": {
      "recording_start_time": "2025-12-30T10:58:24.960Z",
      "buffer_size": 0
    }
  }
}
```

**Payload Schema**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `previous_mode` | Enum | Yes | The mode the server was in before this change. |
| `current_mode` | Enum | Yes | The new mode the server is now in. |
| `reason` | String | No | Human-readable reason for the mode change. |
| `mode_data` | Object | No | Additional data specific to the new mode. |

**Mode Enumeration**:

| Mode | Description |
|------|-------------|
| `idle` | Server is initialized but no client connected |
| `listening` | Server is listening for wake word, audio streaming active |
| `recording` | Server is actively recording audio after wake word |
| `transcribing` | Server is transcribing recorded audio |
| `streaming` | Real-time audio streaming is active |

---

#### 4.3.3 Status Update

**Type**: `status_update`

General status updates from the server, typically used for progress reporting.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440002",
  "type": "status_update",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "payload": {
    "message": "Transcribing audio segment...",
    "level": "info",
    "code": "TRANSCRIBING",
    "progress": 0.45,
    "details": {
      "segment_number": 2,
      "total_segments": 3
    }
  }
}
```

**Payload Schema**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `message` | String | Yes | Human-readable status message. |
| `level` | Enum | Yes | Severity level: `debug`, `info`, `warning`, `error`, `critical`. |
| `code` | String | No | Machine-readable status code. |
| `progress` | Number | No | Progress indicator (0.0 to 1.0) for long-running operations. |
| `details` | Object | No | Additional details about the status. |

---

#### 4.3.4 Config Payload

**Type**: `config_payload`

Server sends configuration blocks to the client.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440003",
  "type": "config_payload",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "payload": {
    "config_type": "audio",
    "config_data": {
      "sample_rate": 16000,
      "channels": 1,
      "format": "int16",
      "chunk_size": 960
    },
    "version": "1.0.0",
    "schema_version": "1.0"
  }
}
```

**Payload Schema**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `config_type` | Enum | Yes | Type: `audio`, `wake_word`, `transcription`, `general`, `full`. |
| `config_data` | Object | Yes | Configuration data block. |
| `version` | String | No | Configuration version for caching/invalidation. |
| `schema_version` | String | No | Version of the configuration schema. |

---

#### 4.3.5 Transcription Result

**Type**: `transcription_result`

Result of audio transcription with confidence scores and optional segment details.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440004",
  "type": "transcription_result",
  "timestamp": "2025-12-30T10:58:30.000Z",
  "direction": "server_to_client",
  "payload": {
    "text": "Turn on the living room lights",
    "language": "en",
    "confidence": 0.94,
    "duration": 3.2,
    "processing_time": 0.85,
    "segments": [
      { "start": 0.0, "end": 0.5, "text": "Turn" },
      { "start": 0.5, "end": 1.2, "text": "on the" },
      { "start": 1.2, "end": 2.5, "text": "living room" },
      { "start": 2.5, "end": 3.2, "text": "lights" }
    ],
    "session_id": "sess_abc123"
  }
}
```

**Payload Schema**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `text` | String | Yes | The transcribed text. |
| `language` | String | Yes | Detected or specified language code (e.g., "en"). |
| `confidence` | Number | No | Confidence score (0.0 to 1.0). |
| `duration` | Number | No | Duration of the audio that was transcribed (seconds). |
| `processing_time` | Number | No | Time taken to process the transcription (seconds). |
| `segments` | Array | No | Detailed segment information with timestamps. |
| `session_id` | String | No | Session ID this transcription belongs to. |

---

#### 4.3.6 Error Occurred

**Type**: `error_occurred`

Error occurred during processing with recovery guidance.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440005",
  "type": "error_occurred",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "correlation_id": "original_message_id",
  "payload": {
    "error_code": "INVALID_AUDIO_FORMAT",
    "message": "Audio format 'mp3' is not supported. Use int16 PCM at 16000Hz.",
    "severity": "major",
    "recoverable": true,
    "recovery_action": "Send audio as 16-bit PCM, 16000Hz, mono."
  }
}
```

**Payload Schema**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `error_code` | String | Yes | Machine-readable error code. |
| `message` | String | Yes | Human-readable error message. |
| `severity` | Enum | Yes | `minor`, `major`, or `critical`. |
| `details` | Object | No | Additional error details. |
| `recoverable` | Boolean | No | Whether the error is recoverable. |
| `recovery_action` | String | No | Recommended action to recover from the error. |

**Standard Error Codes**:

| Code | Description |
|------|-------------|
| `AUDIO_BUFFER_OVERFLOW` | Audio buffer exceeded maximum size |
| `TRANSCRIPTION_FAILED` | Transcription process failed |
| `WAKE_WORD_MODEL_ERROR` | Wake word detection model error |
| `SESSION_TIMEOUT` | Session timed out due to inactivity |
| `INVALID_AUDIO_FORMAT` | Received audio format not supported |
| `RATE_LIMIT_EXCEEDED` | Message rate limit exceeded |
| `UNAUTHORIZED` | Client not authorized |
| `VALIDATION_FAILED` | Message failed schema validation |

---

#### 4.3.7 Audio Stream Started

**Type**: `audio_stream_started`

Notification that a client's audio stream has connected successfully.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440006",
  "type": "audio_stream_started",
  "timestamp": "2025-12-30T10:58:00.000Z",
  "direction": "server_to_client",
  "payload": {
    "stream_id": "stream_xyz789",
    "client_info": {
      "user_agent": "JeevesClient/1.0"
    },
    "server_config": {
      "sample_rate": 16000,
      "channels": 1,
      "format": "int16"
    }
  }
}
```

---

#### 4.3.8 Audio Stream Stopped

**Type**: `audio_stream_stopped`

Notification that a client's audio stream has disconnected.

```json
{
  "message_id": "550e8400-e29b-41d4-a716-446655440007",
  "type": "audio_stream_stopped",
  "timestamp": "2025-12-30T10:59:00.000Z",
  "direction": "server_to_client",
  "payload": {
    "stream_id": "stream_xyz789",
    "reason": "client_disconnect",
    "duration_seconds": 60.0
  }
}
```

---

#### 4.3.9 Heartbeat

**Type**: `heartbeat`

Server-initiated keep-alive ping.

```json
{
  "message_id": "hb_001",
  "type": "heartbeat",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "payload": {
    "server_time": "2025-12-30T10:58:25.000Z",
    "uptime_seconds": 3600
  }
}
```

---

### 4.4 Client→Server Messages

#### 4.4.1 Audio Data

**Type**: `audio_data`

Raw audio data chunks from client to server.

```json
{
  "message_id": "audio_001",
  "type": "audio_data",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "format": "int16",
    "sample_rate": 16000,
    "channels": 1,
    "data": "dGVzdCBhdWRpbyBkYXRh",  // Base64 encoded
    "chunk_index": 42,
    "timestamp": "2025-12-30T10:58:25.000Z"
  }
}
```

**Payload Schema**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `format` | Enum | Yes | Audio sample format: `int16`, `int32`, `float32`. |
| `sample_rate` | Integer | Yes | Sample rate in Hz (typically 16000). |
| `channels` | Integer | Yes | Number of audio channels (typically 1 for mono). |
| `data` | Base64 String | Yes | Base64-encoded audio data. |
| `chunk_index` | Integer | No | Index of this audio chunk for ordering. |
| `timestamp` | ISO 8601 | No | Client-side timestamp when audio was captured. |

**Performance Note**: For high-throughput audio streaming, consider sending raw binary audio as WebSocket binary frames instead of JSON-encoded Base64 data. Binary frames should contain raw PCM data (16-bit, 16000Hz, mono).

---

#### 4.4.2 Start Recording

**Type**: `start_recording`

Command to manually start recording audio.

```json
{
  "message_id": "msg_client_001",
  "type": "start_recording",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "command": "start_recording",
    "parameters": {
      "max_duration": 15.0,
      "vad_enabled": true,
      "silence_threshold": 0.01,
      "silence_timeout": 0.7
    }
  }
}
```

---

#### 4.4.3 Stop Recording

**Type**: `stop_recording`

Command to manually stop recording audio.

```json
{
  "message_id": "msg_client_002",
  "type": "stop_recording",
  "timestamp": "2025-12-30T10:58:40.000Z",
  "direction": "client_to_server",
  "payload": {
    "command": "stop_recording",
    "parameters": {
      "finalize_immediately": true
    }
  }
}
```

---

#### 4.4.4 Send Config

**Type**: `send_config`

Client sends configuration to server.

```json
{
  "message_id": "msg_client_003",
  "type": "send_config",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "config_type": "wake_word",
    "config_data": {
      "threshold": 0.6,
      "enabled_words": ["alexa", "hey_siri"],
      "custom_words": ["jarvis"]
    },
    "persist": true
  }
}
```

---

#### 4.4.5 Request Config

**Type**: `request_config`

Client requests server configuration.

```json
{
  "message_id": "msg_client_004",
  "type": "request_config",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "query_type": "config",
    "filters": {
      "config_types": ["audio", "wake_word"]
    }
  }
}
```

---

#### 4.4.6 Request Status

**Type**: `request_status`

Client requests current server status.

```json
{
  "message_id": "msg_client_005",
  "type": "request_status",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "query_type": "status",
    "filters": {
      "include_stats": true,
      "include_session_info": true
    }
  }
}
```

---

#### 4.4.7 Reset Session

**Type**: `reset_session`

Reset the current session state to idle.

```json
{
  "message_id": "msg_client_006",
  "type": "reset_session",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "command": "reset_session",
    "parameters": {
      "clear_buffer": true,
      "reset_mode": "listening"
    }
  }
}
```

---

#### 4.4.8 Ping

**Type**: `ping`

Client keep-alive ping (response to server heartbeat).

```json
{
  "message_id": "ping_001",
  "type": "ping",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "client_time": "2025-12-30T10:58:25.000Z"
  }
}
```

---

#### 4.4.9 Subscribe

**Type**: `subscribe`

Subscribe to specific event types for filtered updates.

```json
{
  "message_id": "msg_client_007",
  "type": "subscribe",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "event_types": ["wake_word_detected", "transcription_result"],
    "all_events": false
  }
}
```

---

#### 4.4.10 Unsubscribe

**Type**: `unsubscribe`

Unsubscribe from previously subscribed event types.

```json
{
  "message_id": "msg_client_008",
  "type": "unsubscribe",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "client_to_server",
  "payload": {
    "event_types": ["status_update"],
    "all_events": false
  }
}
```

---

## 5. Session State Machine

### 5.1 State Diagram

```
                    +-----------------+
                    |      idle       |
                    |  (no client)    |
                    +--------+--------+
                             |
                    WebSocket Connection
                             |
                             v
                    +-----------------+
              +---->|   listening     |
              |     |  (audio stream) |
              |     +--------+--------+
              |              |
              |    Wake Word Detected
              |              |
              |              v
              |     +--------+--------+
              |     |   recording    |
              |     +--------+--------+
              |              |
              |    Silence Detected / Stop Recording
              |              |
              |              v
              |     +--------+--------+
              |     |  transcribing   |
              |     +--------+--------+
              |              |
              |    Transcription Complete
              |              |
              +--------------+

    +--<----<----<----<----+----<----<----<----+
    |                   |                       |
    |         Reset Session                     |
    |                   |                       |
    v                   v                       v
+-------------+  +-------------+  +-------------+
|  DISCONNECT |  |   listening |  |   error     |
+-------------+  +-------------+  +-------------+
```

### 5.2 State Transition Reference

| From State | Event | To State | Description |
|------------|-------|----------|-------------|
| `idle` | WebSocket connected | `listening` | Client establishes connection |
| `listening` | Wake word detected | `recording` | User spoke wake word |
| `listening` | `start_recording` command | `recording` | Manual recording start |
| `recording` | Silence detected | `transcribing` | VAD detected end of speech |
| `recording` | `stop_recording` command | `transcribing` | Manual recording stop |
| `recording` | `reset_session` command | `listening` | Cancel recording |
| `transcribing` | Transcription complete | `listening` | Ready for next command |
| Any state | `reset_session` command | `listening` | Emergency reset |
| Any state | Connection lost | `DISCONNECT` | Client disconnected |

### 5.3 Audio Buffer Behavior by State

| State | Buffer Behavior |
|-------|-----------------|
| `idle` | No audio buffering |
| `listening` | Rolling buffer (last ~3 seconds) for wake word context |
| `recording` | Full capture from wake word to silence |
| `transcribing` | No new audio accepted |
| `DISCONNECT` | Buffer cleared |

---

## 6. Error Handling

### 6.1 Error Response Pattern

All error responses follow a consistent pattern with correlation linking:

```json
{
  "message_id": "error_001",
  "type": "error_occurred",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "correlation_id": "original_message_id",
  "payload": {
    "error_code": "INVALID_AUDIO_FORMAT",
    "message": "Audio format 'mp3' is not supported. Use int16 PCM at 16000Hz.",
    "severity": "major",
    "recoverable": true,
    "recovery_action": "Send audio as 16-bit PCM, 16000Hz, mono."
  }
}
```

### 6.2 Validation Errors

Messages that fail schema validation receive a structured error response:

```json
{
  "message_id": "val_error_001",
  "type": "error_occurred",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "correlation_id": "original_message_id",
  "payload": {
    "error_code": "VALIDATION_FAILED",
    "message": "Message failed schema validation: missing required field 'type'",
    "severity": "minor",
    "details": {
      "validation_errors": [
        { "field": "type", "error": "required field missing" },
        { "field": "message_id", "error": "must be valid UUID" }
      ]
    },
    "recoverable": true,
    "recovery_action": "Resend message with required fields properly formatted."
  }
}
```

### 6.3 Client Error Handling Guidelines

| Error Code | Client Action |
|------------|---------------|
| `VALIDATION_FAILED` | Fix message format and resend |
| `INVALID_AUDIO_FORMAT` | Convert audio to supported format and resend |
| `RATE_LIMIT_EXCEEDED` | Implement backoff and retry |
| `SESSION_TIMEOUT` | Reconnect and reinitialize session |
| `UNAUTHORIZED` | Obtain valid authentication token |
| `AUDIO_BUFFER_OVERFLOW` | Reduce audio chunk size or rate |

### 6.4 Reconnection Strategy

```javascript
function handleDisconnection(error) {
  const errorCode = error?.payload?.error_code;
  
  if (errorCode === 'SESSION_TIMEOUT') {
    // Immediate reconnect allowed
    reconnectWithBackoff(0);
  } else if (errorCode === 'RATE_LIMIT_EXCEEDED') {
    // Exponential backoff
    reconnectWithBackoff('exponential');
  } else if (errorCode === 'UNAUTHORIZED') {
    // Refresh token first
    refreshAuthToken().then(reconnect);
  } else {
    // Default: retry with 5 second delay
    reconnectWithBackoff(5000);
  }
}
```

---

## 7. Heartbeat / Ping-Pong

### 7.1 Keep-Alive Mechanism

The protocol uses a bidirectional heartbeat system to detect connection health:

| Direction | Message Type | Interval | Timeout |
|-----------|--------------|----------|---------|
| Server → Client | `heartbeat` | 30 seconds | 10 seconds |
| Client → Server | `ping` | Response to heartbeat | 5 seconds |

### 7.2 Heartbeat Sequence

```
Server                                          Client
  |                                               |
  |<---- Client sends audio_data -----------------| (regular traffic)
  |                                               |
  |---- Heartbeat (30s interval) -------------->|
  |                                               |
  |<---- Ping response --------------------------| (within timeout)
  |                                               |
  |-- Heartbeat (30s interval) ---------------->|
  |                                               |
  |                            (no response)     |
  |                                               |
  |<---- CONNECTION TIMEOUT ---->|  (after 10s)
  |                                               |
  |---- Close connection -------|
```

### 7.3 Heartbeat Message Examples

**Server Heartbeat**:

```json
{
  "message_id": "hb_server_001",
  "type": "heartbeat",
  "timestamp": "2025-12-30T10:58:25.000Z",
  "direction": "server_to_client",
  "payload": {
    "server_time": "2025-12-30T10:58:25.000Z",
    "uptime_seconds": 3600
  }
}
```

**Client Ping Response**:

```json
{
  "message_id": "ping_client_001",
  "type": "ping",
  "timestamp": "2025-12-30T10:58:25.100Z",
  "direction": "client_to_server",
  "payload": {
    "client_time": "2025-12-30T10:58:25.100Z",
    "latency_ms": 50
  }
}
```

### 7.4 Client Implementation Recommendations

```javascript
class HeartbeatHandler {
  constructor(websocket, options = {}) {
    this.interval = options.interval || 30000;
    this.timeout = options.timeout || 10000;
    this.lastPing = null;
    this.lastPong = null;
    
    // Start heartbeat timer
    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.interval);
    
    // Set up pong timeout
    websocket.on('pong', () => this.handlePong());
  }
  
  sendHeartbeat() {
    const now = Date.now();
    this.lastPing = now;
    
    // Wait for pong response
    this.pongTimeout = setTimeout(() => {
      if (this.lastPong && this.lastPong < this.lastPing) {
        this.handleTimeout();
      }
    }, this.timeout);
  }
  
  handlePong() {
    this.lastPong = Date.now();
    clearTimeout(this.pongTimeout);
  }
  
  handleTimeout() {
    // Connection lost - trigger reconnection
    this.reconnect();
  }
}
```

---

## 8. Best Practices

### 8.1 Connection Management

1. **Auto-Reconnect**: Implement automatic reconnection with exponential backoff
2. **Connection State**: Track connection state and prevent duplicate connections
3. **Graceful Shutdown**: Send `reset_session` before disconnecting when possible
4. **Resource Cleanup**: Unsubscribe from events before closing connection

### 8.2 Message Handling

1. **Validate Messages**: Always validate message structure before processing
2. **Handle Unknown Types**: Log unknown message types but continue operation
3. **Correlation Tracking**: Store `message_id` for requests to match responses
4. **Rate Limiting**: Respect server rate limits to avoid `RATE_LIMIT_EXCEEDED`

### 8.3 Audio Streaming

1. **Chunk Sizing**: Use 960 samples per chunk at 16000Hz (~60ms)
2. **Buffer Management**: Maintain minimal buffer latency
3. **Timestamps**: Include client timestamps for synchronization
4. **Format Consistency**: Always use int16 PCM unless negotiated otherwise

### 8.4 Error Resilience

1. **Non-Blocking Errors**: Handle errors without blocking audio stream
2. **Retry Logic**: Implement retry with backoff for transient failures
3. **Fallback Modes**: Have fallback behavior for critical errors
4. **Logging**: Log errors with correlation IDs for debugging

### 8.5 Security Considerations

1. **Authentication**: Include `auth_token` in initial connection handshake
2. **TLS**: Use `wss://` in production environments
3. **Input Validation**: Validate all incoming messages server-side
4. **Size Limits**: Enforce maximum message size (1MB for audio chunks recommended)

### 8.6 Performance Optimization

1. **Binary Frames**: Use WebSocket binary frames for audio data instead of Base64 JSON
2. **Batching**: Batch multiple small messages when possible
3. **Compression**: Enable WebSocket per-message-deflate extension
4. **Connection Pooling**: Maintain connection for multiple requests

---

## 9. Example Session Flows

### 9.1 Complete Wake Word Session

```
Client                              Server
  |                                    |
  |---- Connect to /ws --------------->|
  |<--- audio_stream_started ---------|  (With config)
  |                                    |
  |---- audio_data (continuous) ----->|  (16kHz, mono, int16)
  |                                    |
  |<--- heartbeat --------------------|  (Every 30s)
  |---- ping ------------------------>|  (Response)
  |                                    |
  |<--- wake_word_detected ------------|  (Wake word detected)
  |<--- session_mode_changed ---------|  (listening -> recording)
  |<--- status_update ----------------|  (Recording...)
  |                                    |
  |---- audio_data (recording) ------->|  (Command audio)
  |                                    |
  |<--- session_mode_changed ---------|  (recording -> transcribing)
  |<--- status_update ----------------|  (Transcribing...)
  |<--- transcription_result ---------|  (Final text)
  |<--- session_mode_changed ---------|  (transcribing -> listening)
  |<--- status_update ----------------|  (Listening...)
  |                                    |
  |---- audio_data (continuous) ----->|  (Back to continuous mode)
```

### 9.2 Manual Recording Session

```
Client                              Server
  |                                    |
  |---- audio_data (continuous) ----->|  (In listening mode)
  |                                    |
  |---- start_recording --------------->|
  |<--- session_mode_changed ---------|  (listening -> recording)
  |<--- status_update ----------------|  (Recording...)
  |                                    |
  |---- audio_data (recording) ------->|  (Manual recording)
  |                                    |
  |---- stop_recording --------------->|
  |<--- session_mode_changed ---------|  (recording -> transcribing)
  |<--- transcription_result ---------|  (Manual recording result)
  |<--- session_mode_changed ---------|  (transcribing -> listening)
  |                                    |
```

### 9.3 Error Recovery Session

```
Client                              Server
  |                                    |
  |---- audio_data (continuous) ----->|
  |                                    |
  |<--- error_occurred ---------------|  (INVALID_AUDIO_FORMAT)
  |    (correlation_id: msg_123)      |
  |                                    |
  |---- stop_recording --------------->|
  |<--- session_mode_changed ---------|  (recording -> listening)
  |                                    |
  |---- audio_data (correct format) ->|  (Fixed format)
  |                                    |
```

---

## 10. Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-12-30 | Initial protocol specification |

---

## Appendix A: Quick Reference Card

### Message Envelope (All Messages)

```json
{
  "message_id": "UUID",
  "type": "message_type",
  "timestamp": "ISO8601",
  "direction": "server_to_client | client_to_server",
  "payload": { },
  "metadata": { },
  "correlation_id": "UUID"
}
```

### Common Server→Client Types

| Type | Purpose |
|------|---------|
| `wake_word_detected` | Wake word trigger |
| `session_mode_changed` | State transition |
| `status_update` | Progress reports |
| `transcription_result` | Audio transcription |
| `config_payload` | Server config |
| `error_occurred` | Error reporting |
| `heartbeat` | Keep-alive |

### Common Client→Server Types

| Type | Purpose |
|------|---------|
| `audio_data` | Audio streaming |
| `start_recording` | Begin capture |
| `stop_recording` | End capture |
| `send_config` | Update config |
| `request_status` | Query status |
| `ping` | Keep-alive response |

### State Machine

`idle` → `listening` → `recording` → `transcribing` → `listening`

---

*For questions or clarifications, contact the Jeeves development team.*
